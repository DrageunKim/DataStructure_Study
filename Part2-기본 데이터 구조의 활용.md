### 2장 : 스위프트의 표준 라이브리러리를 살펴보기

> 배열, 딕셔너리, 세트, 튜플 등 컬렉션 타입을 위주로 알아봄

***

#### 1. 스위프트 표준 라이브러리의 활용

- 개발자에게 있어 스위프트 표준 라이브러리는 스위프트 프로그래밍 언어와 구분되는 별개의 요소이자,
  클래스, 구조체, 열거형, 함수, 프로토콜 등 스위프트 언어를 활용하기 위한 핵심 도구!
  - 개발자는 표준 라이브러리를 레고 블록 삼아 자신이 원하는 애플리케이션을 만드는데 활용



#### 2. 애플이 구조체를 사용하는 이유

- 스위프트에 정의된 타입 대부분은 구조체
  - 상속, 초기화 해제객체, 레퍼런스 카운딩등 다양한 기능을 제공하는 클래스에 비해
    훨씬 제한된 수의 기능을 제공하는 스위프트가 표준 라이브러리의 구성요소로 적합하기 때문
- 구조체의 이런 단순성은 작성된 코드를 체계적으로 안정화시키며,
  특정 구조체를 변경해도 애플리케이션의 다른 부분은 이에 영향을 받지 않을 수 있음

- 스위프트는 구조체에 클래스의 각종 기능을 추가하였음
  - 커스텀 초기화 함수 사용 가능
  - 메소드를 지닐 수 있음
  - 프로토콜을 구현할 수 있음
- 아래 조건 중 하나라도 해당될 경우 구조체를 사용하는 것을 권장
  - 간단한 몇 개의 값을 캡슐화
  - 캡슐화한 값을 복사를 할 경우
  - 저장되는 프로퍼티가 복사를 위한 밸류 타입인 경우
  - 상속할 필요가 없는 경우



#### 3. 스위프트에서 배열 선언

> 배열은 순위 목록에 동일 타입의 값을 저장하는 데이터 타입
>
> - 반드시 동일 타입의 값만 저장
> - 제너릭 타입의 컬렉션으로 int,float,string, 열거형, 클래스까지 포함 가능
> - 클래스가 아닌 구조체로 정의됨

##### a. 배열 초기화

- 구조체, 클래스, 열거형의 초기화 작업을 위해 init 메소드를 사용

- 초기화 방법

  ```swift
  /* 배열 생성을 위한 정식표현 문법 */
  var intArray = Array<Int>()
  
  /* 배열 생성을 위한 단축 표현 문법 */
  var intArray = [Int]()
  
  /* 배열 리터럴 선언 방식 */
  var intLiteralArray: [Int] = [1, 2, 3]
  
  /* 배열 리터널 단축 선언 방식 */
  var intLiteralArray = [1, 2 ,3]
  
  /* 기본값으로 배열 생성하기 */
  var intLiteralArray = [Int](count: 5, repeatedValue: 2)
  ```

##### b. 배열에 요소 추가 및 업데이트

- 배열의 맨 마지막 부분에 새로운 요소를 추가할 때는 `append(_:)` 메소드를 사용

- 배열에서 원하는 인덱스 위치에 요소를 추가할 때는 `insert(newElement: at:)` 메서드를 사용

  ```swift
  // 기존 배열 [50, 60, 70]
  intArray.insert[newElement: 55, at: 1]
  // 변경 배열 [50, 55, 60, 70]
  intArray.insert[newElement: 65, at: 3]
  // 변경 배열 [50, 55, 60, 65, 70]
  ```

- 특정 인덱스 위치의 배열 요소를 교체할 때는 서브스크립트 문법을 사용

  ```swift
  // 기존 배열 [50, 55, 60, 65, 70]
  intArray[2] = 63
  // 변경된 배열 [50, 55, 63, 65, 70]
  ```

##### c. 배열에서 요소 가져오기 및 삭제 (🙃 삭제는 왜 안알려주는거지??)

- 배열의 인덱스를 알고 있거나 인덱스의 범위를 알고 있을 경우 배열 서브스크립트 기법을 사용

- 배열에 특정 요소가 포함되어 있는지 확인 가능

  ```swift
  // 기존 배열 [50, 55, 63, 65, 70]
  
  /* 인덱스 값으로 배열 요소를 가져옴 */
  intArray[3] // return 65
  
  /* subRange로 해당 범위의 배열 요소를 가져옴 */
  intArray[2..<4] // return [63, 65]
  
  /* 순환문을 사용한 배열요소를 순회 */
  for element in intArray {
    print(element)
  }
  // 50
  // 55
  // 63
  // 65
  // 70
  
  /* 배열에 해당 값이 포함되어 있는지 확인 */
  intArray.contains(55) // return true
  ```



#### 4. 딕셔너리 가져오기 및 초기화하기

> 동일한 데이터 타입이 키와 값 쌍으로 묶여 있는 무순위 컬렉션
>
> - 순위를 별도로 지정할 수 있는 방법이 없음 **(무순위 컬렉션)**

##### a. 딕셔너리 초기화하기

```swift
/* 딕셔너리의 정식 선언 문법 */
var myDict = Dictionary<Int, String>()

/* 딕셔너리의 단축 선언 문법 */
var myDict = [Int: String]()
```

- 키와 값은 콜론(:) 기호로 구분
- 딕셔너리 선언시 무조건 해당 데이터 타입을 별도로 명시할 필요는 없음

```swift
/* 명시적인 딕셔너리 선언 */
var myDict: [Int: String] = [1: "One", 2: "Two"]

/* 단축형 딕셔너리 선언 */
var myDict = [1: "One", 2: "Two"]
```

##### b. 키/값 쌍 추가, 변경, 삭제

- 키/값을 추가하거나, 기존의 값을 업데이트 할 경우 `updateValue(_:forkey) 메소드, 서브스크립트 사용

  - 키/값이 없을 경우 새로운 키/값이 추가됨

  ```swift
  /* 딕셔너리에 새로운 쌍 추가 */
  myDict.updateValue("Four", forKey: 4)
  // [4: Four] 추가
  
  /* 서브스크립트 문법으로 새로운 쌍 추가 */
  myDict[5] = "Five"
  // [5: Five] 추가
  ```

- 키값을 삭제할 경우 `removeValue(forKey:) 메소드에서 삭제하려는 값의 키를 입력
  서브스크립트를 사용할 경우 키에 nil을 전달하면 됨

  ```swift
  /* 딕셔너리에서 키/값 쌍 삭제하고 삭제된 쌍 반환 */
  let removedPair = myDict.removeValue(forKey: 1)
  // [1: One] 삭제
  
  /* 서브스크립트로 딕셔너리에서 키/값 삭제 */
  myDict[2] = nil
  // [2: Two] 삭제
  ```

##### c. 딕셔너리에서 값 가져오기

- 서브스크립트 문법을 이용해서 딕셔너리에서 특정 키/값 쌍을 가져올 수 있다
  - 서브스크립트 **옵셔널**을 반환

- 딕셔너리에서 키 또는 값만을 개별적으로 가져오고 싶다면

  - 딕셔너리의 key 프로퍼티 사용
  - 딕셔너리의 values 프로퍼니 사용

  ```swift
  /* 순환문을 통해 key 프로퍼티를 사용하여 value값 가져오기 */
  for (stateAbbr) in states.keys {
    print("\(stateAbbr)")
  }
  
  /* 순환문을 통해 value 프로퍼티를 사용하여 key값 가져오기 */
  for (stateName) in states.value {
    print("\(stateName)")
  }
  ```

##### d. 딕셔너리에서 값을 정렬

- 전역 메소드인 sort(_:) 를 사용

  ```swift
  /* 키 값을 기준으로 딕셔너리를 정렬
  let sortedArrayFromDictionary = states.sort({ $0.0 < $1.0 })
  ```



#### 5. 세트 선언

> 서로 중복되지 않고 무순위 컬렉션
>
> - 순위가 중요하지 않을 때 사용하는 배열을 대신하여 사용 가능
> - 세트 요소의 값은 서로 중복되지 않음

##### a. 세트 초기화

- 세트의 경우 다른 컬렉션 타입과 달리 `개발자가 직접 Set 타입을 명시적으로 선언`

  ```swift
  /* 세트 선얼을 위한 정식 문법 */
  var stringSet = Set<String>()
  
  /* 배열 요소로 세트 초기화 */
  var stringSet: Set = ["Mary", "John", "Sally"]
  ```

##### b. 세트 요소 변경 및 가져오기

- 세트에 새로운 요소를 추가하려면 `insert(_:)` 메서드 사용
- 값이 이미 세트에 포함되어 있는지 확인하려면 `contain(_:)` 메서드 사용
- 세트에 포함되어 있는 값을 삭제하려면 `remove(_:)` 메서드 사용
  - 세트에 있는 모든 값을 삭제하려면 `removeAll()` 메서드 사용
- 세트에 포함되어 있는 값을 정렬하려면 `sorted()` 메서드 사용

##### c. 세트 연산자

> 세트는 수학에서의 **집합 개념을 기반**으로 만든 타입

- union(_:) = 합집합
- Intersection(_:) = 교집합
- symmetricDifference(_:) = 여집합
- subtracting(_:)  = 차집합

##### d. 부분 집합 및 동등 연산자

- 두 개의 세트에 속한 내부 요소가 서로 완전히 같을 경우, 두 세트는 동등하다고 표현

  ```swift
  var sourceSet: Set = [1, 2, 3]
  var destSet: Set = [2, 1, 3]
  
  var isequal = sourceSet == destSet
  // isequal = true
  ```



#### 6. 튜플의 특징

> 튜플은 고급 타입

- 튜플은 배열, 딕셔너리, 세트와 같은 컬렉션 타입은 아니지만, 컬렉션과 비슷한 특징을 지님

- 튜플은 다양한 데이터 타입을 담을 수 있는 특징을 지님 (내부 요소에 모두 같은 타입일 필요는 없음)

- 튜플은 내부 요소의 순회가 불가능함
- 튜플은 메소드를 통해 구조화된 값을 임시로 전달할 때 특히 유용한 타입

- 복합적인 데이터 구조를 만드는데 적합하지 않음!

```swift
let responseCode = (4010, "Invalid File Contents", 0x21451fff3b)

/* 분할 사용 방법 */
let (errorCode, errorMessage, offset) = responseCode
// errorCode = 4010
// errorMessage = "Invalid File Contents"
// offset = 0x21451fff3b
```

##### a. 기명 튜플

> 기명 튜플은 개별 요소에 이름을 붙일 수 있는 튜플

- 메소드를 통해 튜플을 반환할 때 특정 인덱스 위치에 어떤 값이 있는지 알기 쉽게 도와줌

```swift
let responseCode = (errorCode: 4010, errorMessage: "Invalid File Contents", offset: 0x21451fff3b)
// responseCode.errorCode = 4010
// responseCode.errorMessage = "Invalid File Contents"
// responseCode.offset = 0x21451fff3b
```


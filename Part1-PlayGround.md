### 1장 : 데이터 구조와 알고리즘이 무엇이고 왜 중요한지에 대한 설명

> 문제를 해결하기 위해서는 적절한 데이터 구조 + 알고리즘을 선택하는 것이 애플리케이션의 유용성을 결정!

***

## 1. 기본적인 데이터 구조

데이터의 가장 근원적인 형태는 배열과 포인터 두가지 타입!

- 인접 데이터 구조 : 데이터를 메모리 영역 중 인접한 부분에 저장

  - 배열, 힙, 매트릭스, 해시테이블 등이 있음

    선형 데이터 구조를 이루고 있음

  - 일정한 순서에 따라 개별 데이터 요소에 접근할 수 있는 인덱스 기반의 데이터 구조

- 연결 데이터 구조 : 서로 명확히 구분되는 메모리 영역을 차지, 포인터라는 주소 체계로 연결 관리하는 구조

  - 목록, 트리, 그래프 등이 있음

### 배열

- 데이터 구조 가운데 가장 널리 사용

- 1차원 배열이라고도 하는 선형 배열, 행렬은 다차원 배열의 대표적인 형식

     - 배열 선언 : 총 3가지 있음

       ```swift
       /* 1. 기본 방법 */
       var myIntArray: Array<Int> = [1, 3, 5, 7, 9]
       
       /* 2. 축약형 방법 */
       var myIntArray: [Int] = [1, 3, 5, 7, 9]
       
       /* 3. 배열 타입의 추측을 위한 문법 */
       var myIntArray = [1, 3, 5, 7, 9]
       
       /* 배열에 아무것도 넣고 싶지 않을 경우 */
       var myIntArray: [Int] = []
       
       /* 다중 배열을 선언하려고 할 때, 대괄호 안에 다시 또 다른 대괄호를 추가 */
       var my2DArray: [[Int]] = [[1, 2], [10, 11], [20, 30]]
       ```

  - 배열 값 접근

    ```swift
    /* 1차원&다차원 배열 선언 */
    var myIntArray: [Int] = [1, 3, 5, 7, 9]
    var my2DArray: [[Int]] = [[1, 2], [10, 11], [20, 30]]
    
    /* 원하는 인덱스에 저장된 값 접근 */
    var someNumber = myIntArray[2] // someNumber = 5
    
    /* for-in을 활용한 전체 값 접근 */
    for element in myIntArray {
      print(element) // 1, 3, 5, 7, 9
    }
    
    /* 일정 범위에 있는 값을 배열로 가져오는 방식 */
    var someSubset = myIntArray[2...4] // someSubset = [5, 7, 9]
    
    /* 2차원 배열에서 특정 배열 요소를 가져오는 방식 */
    var element = my2DArray[0][0] // element = 1
    element = my2DArray[0][1] // element = 2
    element = my2DArray[1][0] // element = 10
    element = my2DArray[1][1] // element = 11
    ```

  - 배열 값 추가

    ```swift
    /* 1차원 배열 선언 */
    var myIntArray: [Int] = [1, 3, 5, 7, 9]
    
    /* 가장 끝에 요소를 추가 */
    myIntArray.append[10] // myIntArray = [1, 3, 5, 7, 9, 10]
    
    /* 원하는 인덱스 위치에 요소를 추가 */
    myIntArray.insert(4, at:2) // myIntArray = [1, 3, 4, 5, 7, 9]
    ```

  - 배열 값 삭제

    ```swift
    /* 1차원 배열 선언 */
    var myIntArray: [Int] = [1, 3, 5, 7, 9]
    
    /*가장 끝에 요소를 삭제 */
    myIntArray.removeLast() // myIntArray = [1, 3, 5, 7]
    
    /* 원하는 인덱스 위치에 요소를 삭제 */
    myIntArray.remove(at: 3) // myIntArray = [1, 3, 5, 9]
    ```

    > :star:  배열은 스택, 큐, 힙, 해시 테이블, 문자열 등 다양한 데이터 구조를 표현하는데 사용!

***

## 2. 연결 데이터 구조

- 연결리스트 : 데이터 + 다음 노드에 연결할 수 있는 레퍼런스(또는 링크) 정보를 포함

  - 추가 노드를 삽입하거나 삭제하는 일은 매우 간단!
    - S 노드 : 단일 연결 리스트
    - N 노드 : 단일 연결 리스트의 마지막 부분
    - D 노드 : 이중 연결 리스트

  1. 단일 연결 리스트

     ```swift
     class LinkedList<T> {
       var item: T? // LinkedList의 값
       var next: LinkedList<T>? // 다음 LinkedList와 연결
     }
     
     /* <T> & T? 는 Generic은 타입으로 모든 타입을 받고 싶을 때 사용
     <T> 를 붙임으로써 class가 Generic 타입이라는 것을 알려줌
     T? 를 붙임으로써 item에 모든 타입의 값이 올 수 있으며 Optional로 처리됨 */
     
     // 나중에 Generic은 상세히 알아볼 예정이니 지금은 요기까지만;;;
     ```

     > :fire: 연결 리스트의 상세한 내용은 3장에서 다뤄볼 예정!

***

## 3. 데이터 구조의 종류와 장단점

1. 배열
   - 장점
     - 인덱스 값을 미리 알고 있을 경우, 데이터에 매우 신속하게 접근
     - 새로운 요소를 매우 신속하게 삽입
   - 단점
     - 크기가 고정!!!
     - 삭제 및 검색이 느림
2. 큐
   - 장점 : FIFO 접근 방식 (먼저 입력된 데이터가 먼저 출력)
   - 단점 : 접근속도 느림
3. 스택
   - 장점 : LIFO 접근 방식 (나중에 입력된 데이터가 먼저 출력)
   - 단점 : 접근속도 느림
4. 리스트
   - 장점 : 데이터 삽입 및 삭제 속도가 빠름
   - 단점 : 검색속도 느림
5. 해시테이블
   - 장점 : 키값을 미리 알고 있을 경우, 데이터에 신속하게 접근 & 새로운 요소 신속하게 삽입
   - 단점 : 키값을 모르면 느리고, 메모리 효율이 떨어짐
6. 힙
   - 장점 : 매우 신속하게 삽입 및 삭제 가능, 최대 혹은 최소 항목에 대한 접근속도 빠름
   - 단점 : 다른 요소에 접근이 느림
7. 트라이
   - 장점 : 데이터 접근 속도가 매우 빠름, 서로 다른 키값에 대한 충돌 가능성 없음
   - 단점 : 특정 상황에서 해시 테이블보다 속도가 느림
8. 이진 트리
   - 장점 : 균형 잡힌 트리 구조인 경우, 삽입, 삭제, 검색 속도 빠름
   - 단점 : 삭제 알고리즘 작성이 복잡할 수 있음, 삽입 순서에 영향을 받으며 성능 저하가 될 수 있음

9. 레드블랙 트리
   - 장점 : 삽입, 삭제, 검색속도 매우 빠르고, 트리는 항상 균형 상태를 유지
   - 단점 : 한계 상황에서 데이터 구조를 운영하므로 구현이 매우 까다로움
10. R트리
    - 장점 : 공간적 데이터를 나타날 때 좋으며, 2차원 이상의 구조를 지원
    - 단점 : 성능 검증이 확실하지 않음
11. 그래프
    - 장점 : 실제 세계의 상황을 반영한 모델을 구현
    - 단점 : 일부 알고리즘은 느리고 복잡

#### 알고리즘 개요

> :star: 알고리즘을 작성하려면, 시간과 공간이 필요하며 이 두가지가 가장 중요한 자원!
>
> 좋은 알고리즘이라면 규모가 큰 문제일수록 좀 더 신속하게 해결해야함을 의미

- 데이터 구조에서 필수적인 파악해야하는 내용
  - 새로운 데이터 삽입하는 방법
  - 데이터 삭제하는 방법
  - 특정 데이터를 찾는 방법
  - 모든 데이터를 순회하는 방법
  - 데이터를 정렬하는 방법

#### 스위프트에서의 데이터 타입

- 원천 데이터 타입은 단일 값을 지닌 스칼라 타입을 일컫는 경우가 많음
  - 스칼라 타입 데이터 : int, float, double, char, bool
  - Swift에서 원천 데이터 타입은 스칼라 타입으로 구현되어 있지 않음

#### 밸류 타입과 레퍼런스 타입

- 기본 데이터 타입은 밸류 타입과 래퍼런스 타입 두가지

  - 밸류 타입은 오직 하나의 소유 객체만을 지님

    - 밸류 타입의 데이터가 변수나 함수에 전달되었을 때, 지니고 있는 값을 복사
    - 밸류 타입은 구조체와 열거형, 두가지 유형
    - Swift의 모든 데이터 타입은 기본적으로 구조체

  - 레퍼런스 타입은 밸류 타입과 달리 값을 복사하지 않고 공유

    - 레퍼런스 타입의 데이터를 변수나 함수에 전달할 때, 값을 복사해서 제공하는 대신,

      동일한 인스턴스를 참조값으로 활용!

    - 레퍼런스 타입은 여러 개의 소유 객체가 참조라는 방식으로 공유
    - 레퍼런스 타입은 클래스와 클로져, 두가지 유형

> # :dragon: 
>
> 밸류 타입은 새로운 메모리가 할당(Stack에 저장)되어 새로운 값이 생성되는 방식
>
> 레퍼런스 타입은 값을 공유하는 것이고, 메모리 Heap에 저장되며 다른 곳에서 값이 바뀌면 전체적으로 변경

#### 기명 타입과 복합 타입

- 기명 타입은 사용자가 정의할 수 있는 데이터 타입
  - 클래스, 구조체, 열거형, 프로토콜
  - 배열, 딕셔너리, 세트, 옵셔널 값
- 복합 타입은 별도의 이름이 붙여지지 않은 타입
  - 함수, 튜플
    - Ex) 튜플은 두 개의 요소를 포함, Int + (Float, Float) 은 (Int, (Float), (Float)) 이라는 복합 타입

#### 타입 에일리어스

- 기존 타입을 또 따른 이름으로 부를 수 있는 방법
- C언어에서 typedef와 유사

```swift
/* 기존 UInt16 타입을 TCPPacket이라는 식별자로 이름을 붙일 수 있음 */
typealias TCPPacket = UInt16
var maxTCPPacketSize = TCPPacket.max // 65535
```

#### 스위프트 표준 라이브러리의 컬렉션 타입

- 배열, 딕셔너리, 세트 등 세가지의 컬렉션 타입을 제공
- 튜플은 정식 컬렉션 타입은 아니지만 수, 문자열 등 복합적인 값을 한번에 묶어서 사용할 수 있음

***

## 4. 점근적 분석

- 무한대에 가까운 입력값을 분석하는데 걸리는 시간을 측정하는 방법
- 최적의 성능을 낼 수 있는지를 확인하기 위해 알고리즘의 실행 속도를 측정
  - 최악의 상황이라면, 얼마만큼의 **저장공간**이 필요한지?
  - 알고리즘이 특정 규모의 입력값을 처리하는데 **걸리는 시간**을 얼마인지?
    - :star: 저장공간과 걸리는 시간이 중요!

#### 데이터 크기 분석 방법

- 정렬 알고리즘의 실행 시간 측정에 있어서 사실 정확한 값은 중요하지 않다
- 빅오는 함수의 점근적 분석을 표현하는 가장 대표적인 방법

> 대규모 입력 데이터에서는 병합형 정렬 알고리즘이 삽입형 정렬 알고리즘에 비해
>
> 훨씬 더 나은 성능을 낸다는 것을 알 수 있음 (P50~55)

***

## 5. 정리

- 데이터 구조와 알고리즘의 중요성에 대해 간단히 알아봄

  - 어려운 문제를 해결하기 위해 데이터 구조와 알고리즘에 대한 넓고 깊은 이해가 필요함

    
